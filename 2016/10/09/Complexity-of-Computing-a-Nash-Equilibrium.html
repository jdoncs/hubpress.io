<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Complexity of Computing a Nash Equilibrium</title>
    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://jdoncs.github.io/favicon.ico">

    <link rel="stylesheet" type="text/css" href="//jdoncs.github.io/themes/casper/assets/css/screen.css?v=1476023861886" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />

    <link rel="canonical" href="https://jdoncs.github.io/2016/10/09/Complexity-of-Computing-a-Nash-Equilibrium.html" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Complexity of Computing a Nash Equilibrium" />
    <meta property="og:description" content="Paper Here What is this paper about? In game theory, we study the behaviour of rational agents in various model problems. The classic example is the Prisoner&amp;#8217;s Dilemma. Problems in game theory are modeled using the notation of a game. In a game, each actor (player) has a" />
    <meta property="og:url" content="https://jdoncs.github.io/2016/10/09/Complexity-of-Computing-a-Nash-Equilibrium.html" />
    <meta property="article:tag" content="Game Theory" />
    <meta property="article:tag" content=" Computational Complexity" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Complexity of Computing a Nash Equilibrium" />
    <meta name="twitter:description" content="Paper Here What is this paper about? In game theory, we study the behaviour of rational agents in various model problems. The classic example is the Prisoner&amp;#8217;s Dilemma. Problems in game theory are modeled using the notation of a game. In a game, each actor (player) has a" />
    <meta name="twitter:url" content="https://jdoncs.github.io/2016/10/09/Complexity-of-Computing-a-Nash-Equilibrium.html" />
    
    <script type="application/ld+json">
null
    </script>

    <meta name="generator" content="HubPress" />
    <link rel="alternate" type="application/rss+xml" title="" href="https://jdoncs.github.io/rss/" />
</head>
<body class="post-template tag-Game-Theory tag-Computational-Complexity nav-closed">

    

    <div class="site-wrapper">

        


<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
    </nav>
</header>

<main class="content" role="main">
    <article class="post tag-Game-Theory tag-Computational-Complexity">

        <header class="post-header">
            <h1 class="post-title">Complexity of Computing a Nash Equilibrium</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2016-10-09">09 October 2016</time>  on <a href="https://jdoncs.github.io/tag/Game-Theory/">Game Theory</a>, <a href="https://jdoncs.github.io/tag/Computational-Complexity/"> Computational Complexity</a>
            </section>
        </header>

        <section class="post-content">
            <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://people.csail.mit.edu/costis/simplified.pdf">Paper Here</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_this_paper_about">What is this paper about?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In game theory, we study the behaviour of rational agents in various model problems. The classic example is the <a href="https://en.wikipedia.org/wiki/Prisoner%27s_dilemma">Prisoner&#8217;s Dilemma</a>. Problems in game theory are modeled using the notation of a game. In a game, each actor (player) has a set of possible actions that they could take. Games are played in a single round, where each player picks an action, and an outcome occurs as a function of the joint actions of all the players. Usually in game theory, we&#8217;re interested in figuring out what rational agents would do when confronted with this problem. We can imagine a rational agent to be a computer program that selects actions to minimize its punishment or maximize its reward.</p>
</div>
<div class="paragraph">
<p>We might wonder whether there&#8217;s always an equilibrium where every player just does one of their actions. It is easy to show that there is not. For example, consider the game Matching Pennies. In this game, each player holds a penny concealed in thier hand. The players can elect to arrange the coin so that either heads or tails will be on top when their palm is opened. The outcome of the game is that if both players reveal the same side of the coin, player 1 gets both pennies. If the players reveal different sides of their coins, player 2 gets them both instead. It should be obvious that deciding to always reveal the same side is a recipe for disaster. An opponent who knows that you&#8217;re doing this could get a penny from you every time! Despite this, there is still a single right way to play this game. Observe that if a player selects heads or tails uniformly at random (i.e. each of them 50% of the time), then it does not matter what their opponent does: the coins will match as often as not. This type of equilibrium is called a mixed strategy <a href="https://en.wikipedia.org/wiki/Nash_equilibrium#Definitions">Nash Equilibrium</a> (because each player picks a mixture of the actions as their strategy for playing the game).</p>
</div>
<div class="paragraph">
<p>Perhaps the biggest result in game theory is Nash&#8217;s theorem. Nash&#8217;s theorem shows something rather exciting: every game has at least one mixed strategy Nash equilibrium. This means that the behaviours of rational agents should always be predictable to some degree (there might be more than one equilibrium, so it might not always be clear which one different rational agents will play). Nash&#8217;s proof shows the existence of such an equilibrium, but it also gives a method for finding it: if the players each adjust their strategies in turn to exploit whatever their opponents are doing now, then play will eventually converge to an equilibrium. However, the proof does not describe how long players might need to do this before reaching the equilibrium. Nor does it tell us whether there&#8217;s a faster way to find the equilibrium that avoids this iterative refinement. The main result of this paper by Papadimitriou et al. is to answer these questions. They accomplish this by showing that finding a Nash Equilibrium is at least as hard as some other problems for which no known fast algorithms exist. Surprisingly, these other algorithms are not NP-Complete, as we often expect, but in a more exotic complexity class called PPAD.</p>
</div>
<div class="sect2">
<h3 id="_complexity">Complexity</h3>
<div class="paragraph">
<p>The problem of finding a mixed strategy Nash Equilibrium is known to be easy when the game consists of two players and is zero-sum. When there are more than 2 players, or the game is not zero-sum, we might wonder how hard it is exactly.</p>
</div>
<div class="paragraph">
<p>Usually computational complexity is expressed (at least, outside of complexity theory conferences and journals) in terms of the two familiar complexity classes seen in an undergraduate course on algorithms: <a href="https://en.wikipedia.org/wiki/P_(complexity)">P</a> and <a href="https://en.wikipedia.org/wiki/NP_(complexity)">NP</a>. P is the set of problems for which there exists a known algorithm that solves problem instances is a number of operations that is a polynomial function of the input size. For example, if the problem is sorting a list of numbers, the existence of a simple, slow, algorithm like Bubble Sort (which needs a number of operations that is a quadratic function of the length of the list) serves to show that the problem of sorting a list of numbers is in P.</p>
</div>
<div class="paragraph">
<p>NP is the set of problems that can be <em>verified</em> in polynomial time. Verification consists of taking a problem instance and proposed solution, and checking whether or not the solution is correct. For example, sorting a list of numbers is in NP because if I give you a list of numbers that are unsorted, and then a list that I claim contains the same numbers in sorted order, you can verify my claim by simply making sure the two lists contain the same numbers (quadratic time if done naively), and then making sure that the second list is indeed sorted (linear time). It should be obvious that every problem in P is also in NP: we can always run the algorithm in a polynomial number of steps, and see if we get a solution. However, there exist problems that can be verified in polynomial time, but for which no polynomial time algorithm is known.</p>
</div>
<div class="paragraph">
<p>An example is something like <a href="https://en.wikipedia.org/wiki/Knapsack_problem">integer knapsack</a>. The integer knapsack problem consists of being given a bag with a certain total capacity (in liters, say), and a multiset of items of different sizes that are worth different amounts. The question that is asked is whether there exists a way to pack the knapsack such that the total value of the items in it is at least k. It should be apparent that brute-forcing this is not an option, since the number of subsets that can fit in the bag is going to be exponential in the size of the multiset. Likewise, it should be obvious that if I present you with a packed bag, it&#8217;s easy to count up the value of the items in the bag, and see whether that&#8217;s more than k or not. There&#8217;s no known deterministic polynomial time algorithm for finding such a packed bag though, so the problem is in NP, but not in P.</p>
</div>
<div class="paragraph">
<p>Finding a Nash Equilibrium is clearly in NP: if I give you a proposed equilibrium, you can check whether any player would want to deviate by computing the gradient of their utility function with respect to the probabilities of playing any given strategy. If the gradient is zero for every player, we&#8217;re at an equilibrium. Similarly, we can&#8217;t be sure whether this problem is in P or not, because we don&#8217;t have an efficient algorithm for solving it (yet). Usually complexity theorists use this starting point to show that a problem is at least as hard as one of the hardest unsolved problems in NP, called the NP-Complete problems. However, most (all?) NP-Complete problems rely on the fact that a solution might not exist,and that proving that there&#8217;s no solution is very difficult without enumerating all possible solutions.</p>
</div>
<div class="paragraph">
<p>My understanding is that this is because the fundamental NP-Complete problem is <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a>, and other problems are reduced to SAT. The authors of this paper give an argument that I found a bit handwavy for this. Basically, if we had an efficient way to translate SAT instances (i.e. answering the question of whether or not a particular boolean formula can ever output true), to instances of NASH (Finding an equilibrium where no player can gain more than some fixed amount \epsilon by playing differently), then we could solve SAT instances by <em>guessing</em> a solution to NASH, and checking whether that solution was a solution to SAT or not. The authors say it is easy to show that this could yield a non-deterministic algorithm for solving SAT efficiently, but I&#8217;m not sure I see how. Obviously solutions will always exist to NASH, since there must be at least one equilibrium with \epsilon=0 by Nash&#8217;s theorem. But would <em>guessing</em> really allow one to find solutions quickly? The authors don&#8217;t say that an efficient non-deterministic algorithm is needed for NASH, but it seems to me like it must be.</p>
</div>
<div class="paragraph">
<p>Anyhow, the point is, complexity theorists have some (inscrutable) reason for thinking that guess and check on NASH would allow efficient non-deterministic solutions to SAT. Therefore they suppose that reductions from SAT to NASH are unlikely to exist. I find this uncompelling, but I&#8217;m not a complexity theorist, and I certainly can&#8217;t find such a reduction myself to contradict them! If Nash were NP-Complete then by definition, an instance of SAT could be turned into NASH efficiently <em>somehow</em>. Therefore, we suppose NASH is probably not NP-Complete.</p>
</div>
<div class="paragraph">
<p>So NASH is easier than NP-Complete problems (or at least, incomparable with them), but it&#8217;s in NP, and we don&#8217;t have any algorithm that would put it in P after about 50 years of trying. A reasonable guess is that NP &gt; NASH &gt; P. As it turns out, there are some other problems that fit this description. Surprisingly, the authors claim (via one of Papadimitriou&#8217;s other papers) that the set of possible problems that are similar is quite small. We&#8217;re just looking for problems that have a non-constructive proof that there is always a solution. The non-constructive step turns out to determine similar sets of problems. PPAD is the set of problems where the non-constructive step in the proof is of the form "If a digraph has one node with different numbers of in- and out-edges, then there must be another such node.".</p>
</div>
<div class="paragraph">
<p>The canonical problem for this class (i.e. the SAT of PPAD) is described as "END-OF-THE-LINE": Given a graph, and a particular vertex with different numbers of in- and out-edges, output some other vertex of the graph that also has different numbers of such edges. Of course, if the graph is provided in a standard format this is a boring (and very simple) problem to solve! Just count the number of edges of each type for every vertex. There are at most |V|^2 directed edges, so work is polynomial.</p>
</div>
<div class="paragraph">
<p>However, END-OF-THE-LINE is proposed to take a rather arcane input format. A graph is represented by two boolean circuits of depth polynomial in the size of the graph. Each circuit takes k binary inputs and produces binary k outputs. The graph has 2^k vertices, and each is constrained to have at most one in-edge and at most one out-edge. The boolean circuits effectively accept a binary number corresponding to a vertex. One of the circuits outputs the target of the out-edge (if any), and the other outputs the target of the in-edge (if any). Oddly, this appears to constrain the graph to having a unique predecessor for each node, even though it could be the successor of many nodes. Weird. The pathological instance of this problem would be to give a source node as the provided vertex with different numbers of in- and out-edges. We know there must be at least one sink in the graph, but since the structure of the graph is encoded only implicitly, we might need to walk through every vertex to find it (e.g. if the "graph" is really a single enormous linked list). Since we cannot examine the boolean circuits (I guess?), this makes END-OF-THE-LINE hard in the worst case, taking apparently exponential time, even though there&#8217;s certain to be a solution, and solutions are easy to verify. My complaint about this part of the paper is that END-OF-THE-LINE&#8217;s encoding seems like a pretty contrived way to represent a graph. I guess it&#8217;s saying: if you can only observe the local topology of a graph (like if you were trapped in a maze), you might have to check every path to find the exit. But the work is still linear in the size of the graph. It&#8217;s only exponential in $k$, and $k$ just seems like a contrived notion. Mostly the design seems to be a theoretical contrivance, insofar as some other hard problems with input sizes of $k$ can be reduced to END-OF-THE-LINE with 2^k vertices. I kind of wish they&#8217;d said so when presenting END-OF-THE-LINE, but I suppose this is the cost of reading outside one&#8217;s core area.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_brouwer_s_theorem_and_ppad_hardness">Brouwer&#8217;s Theorem and PPAD-Hardness</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Okay. So we have that NASH is an important problem, and that probably NP &gt; NASH &gt; P. We also have this weird complexity class PPAD, based around the equally weird problem END-OF-THE-LINE. As one would expect, the meat of the paper is the authors showing that NASH can be converted into END-OF-THE-LINE, and that END-OF-THE-LINE can be converted into NASH. These reductions would establish that NASH is exactly as hard as END-OF-THE-LINE, and frankly, END-OF-THE-LINE seems ridiculously hard (assuming we can&#8217;t examine the boolean circuits, or otherwise infer the graph&#8217;s structure except by walking around on it). To accomplish this, they rely on Brouwer&#8217;s fixed point theorem, which is what&#8217;s used in the core non-constructive step of Nash&#8217;s theorem.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Brouwer_fixed-point_theorem">Brouwer&#8217;s fixed point theorem</a> says that if you map any "reasonable" subset of a Euclidian space to a "reasonable" subspace of itself, there&#8217;s at least one point that doesn&#8217;t move (i.e. the "fixed" point). Here, "reasonable" means that it&#8217;s a contiguous proper sub-region of the space. So the unit ball is good (for any number of dimensions), but something like two disjoint balls isn&#8217;t. If you think about this for a minute, it seems true, though if I think about it for more than a minute I always come up with some weird mapping that seems like it doesn&#8217;t have a fixed point. Later I always figure out what the fixed point is though.</p>
</div>
<div class="paragraph">
<p>Nash&#8217;s theorem relies on this notion of fixed points. The dimensions of the space are given by the set of probabilities that each player uses to decide which strategy to play. This ends up being some sort of scaling of the unit ball for a high dimensional space, since the probabilities for each player need to sum to 1 (so we should get a ball with radius n, for n players. Suppose that players adjust their strategies to improve utility, given the strategies of their opponents. Then each of these points has a successor point, the strategy profile that the players would move to if they started here. The mapping from points to successors is "reasonable", so by Brouwer&#8217;s theorem, there&#8217;s a fixed point, a point where the players don&#8217;t want to move, which must be a mixed strategy Nash equilibrium.</p>
</div>
<div class="paragraph">
<p>The authors propose the computational search problem BROUWER, which takes the unit hyper-cube with m dimensions, and a polynomial-time computable mapping F from points in the cube x to other points in the cube F(x), and produces a fixed point of the mapping. They do this \epsilon-approximate fixed point thing again, apparently because algorithms don&#8217;t do irrational numbers (makes sense: we&#8217;d be "computing" forever just to write down an irrational fixed point). They also require that F obeys a Lipschitz condition: i.e. if two points x and y are a distance d apart, then F(x) and F(y) are no more than K\times d apart for some constant K.</p>
</div>
<div class="paragraph">
<p>To show that BROUWER maps to END-OF-THE-LINE, the authors propose the following technique:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Put down a lattice of points over the hypercube, with spacing that "depends" on K, \epsilon and m. Exactly how this dependency works is not explained. Strangely, this step appears to be exponential in \epsilon and m. The authors don&#8217;t comment on this at all. I believe that the spacing needs to be such that the distance between diagonally adjacent points in the lattice is no more than 2*\epsilon, but this might not quite be correct.</p>
</li>
<li>
<p>For every point in the lattice x, compute F(x), which is an efficient operation.</p>
</li>
<li>
<p>Divide the unit ball of dimension m into three contiguous regions, and color them red, blue and yellow.</p>
</li>
<li>
<p>Compute the direction of the vector F(x) - x, and map that vector onto the unit ball. Color lattice point x based on the corresponding color from step 3. If $F(x) = x$ for any lattice point then we don&#8217;t even need to do the rest of this, so don&#8217;t worry about that case (I think).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Notice that the points along each edge of the hypercube will naturally omit one color: if you&#8217;re as far left as you can go, then there&#8217;s no way to map a point to the left of where it is now, for instance. There&#8217;s a result from combinatorics called <a href="https://en.wikipedia.org/wiki/Sperner%27s_lemma">Sperner&#8217;s Lemma</a> that says if you make this kind of triangular tessellation of a space, and  color the vertices of the tessellation in this way, one of the triangles has a vertex of every one of the three colors. The Lipschitz condition means that if three points are close enough together (again, I wish they&#8217;d be more explicit about the lattice spacing), and yet mapped in three such radically different directions, they&#8217;re near a fixed point of F. This kind of makes sense. The Lipzschitz condition ensures that under $F$, the image of the three points all need to be "close" to each other, within some constant multiple of the distance of the three points in the original arrangement. One supposes that if the lattice is arranged such that the points are within epsilon/K from each other in the original space (which we can do by making the lattice spacing sufficiently small), then the Lipschitz condition ensures that the three points all have to be with \epsilon of each other in the resulting space. So probably the lattice isn&#8217;t spaced with a distance of 2\epsilon, but with a distance of 2\epsilon/K.</p>
</div>
<div class="paragraph">
<p>So now it&#8217;s easy to convert the problem of finding an \epsilon-approximate fixed point (BROUWER) to END-OF-THE-LINE. Make a boolean circuit that encodes the direction of F(x) - x for any mapping. This should be possible because we assumed F was easy to compute. Enumerate  triangles that tesselate the space. There are countably many since the lattice spacing is finite. Build a boolean circuit that maps from each of the triangles to one of its neighbours according to the following rule: If one corner of the triangle is red, and the next corner clockwise from around the parameter is yellow, then create an out edge from the triangle with this number to its neighbour across the edge (here, clockwise just means with respect to some self-consistant view of the points). Notice that this ensures there is at most one out-edge for each triangle, and at most one in-edge for each triangle. You can draw the triangles out to prove this, or just look at this picture from the paper for a while:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/jdoncs/jdoncs.github.io/raw/master/images/Fig7Exerpt.png" alt="Excerpt from Figure 7 of the paper" width="to illustrate the triangle colouring.">
</div>
</div>
<div class="paragraph">
<p>Notice that if a triangle has two yellow vertices, or two red vertices, then it has both an in-edge and an out-edge. If it has two blue-vertices, it has no edges at all. However, there exists triangles on the perimeter of the space that <em>could</em> have an in-edge, but only from a region outside the space. Any such triangle is a source. We know any problem will have at least one of these, because Sperner&#8217;s lemma ensures there&#8217;s a sink in the graph, and the PPAD observation itself ensures that if there&#8217;s a sink then somewhere there must be a source.</p>
</div>
<div class="paragraph">
<p>So we now imagine we had a fast algorithm for END-OF-THE-LINE, meaning one that was polynomial in k. We can define boolean circuits to compute these successor relationships with respect to different points in the space. The only other input PPAD requires is a vertex of this graph that has different numbers of in-edges and out-edges. This would have to be a point with 2 yellow and 1 red vertices (or 1 yellow and 2 red), but located on the the perimeter of the space. The authors use a clever trick to ensure that the perimeter of the space has a side that will start with every vertex along the side colored yellow, and at some point transition to every vertex being colored red. The transition point is sure to be a source, and can be found efficiently by doing, e.g. a binary search along the side, though the authors do not explain this part in detail. Anyway, the point is: we can define the triangles and the boolean circuits in polynomial time, and we can find a source vertex in time that is polynomial in the logarithm of the inverse of the lattice spacing. However, the number of triangles is proportionate to the inverse of the lattice spacing raised to the power of the number of dimensions. So this instance of END-OF-THE-LINE has something like O(2^{\frac{1}{\epsilon}} nodes. Since we assumed there was an END-OF-THE-LINE algorithm that needed a polynomial number of steps in terms of k, and translating BROUWER to END-OF-THE-LINE needed only a polynomial number of steps in \frac{1}{\epsilon}, we can solve BROUWER in a number of steps polynomial in \frac{1}{\epsilon}. From this, we can conclude that BROUWER is no harder than END-OF-THE-LINE. IF we can solve END-OF-THE-LINE in a number of steps polynomial in k, we can also solve BROUWER efficiently with respect to \epsilon.</p>
</div>
<div class="paragraph">
<p>Of course, we were originally interested in NASH, but it&#8217;s easy to see how to turn an instance of NASH into an instance of BROUWER (explained earlier in this post), so it should be apparent that NASH is no harder than BROUWER. This means NASH is PPAD-Hard. Any efficient algorithm for problems in the class PPAD-Complete (like END-OF-THE-LINE) can be converted into an efficient algorithm for NASH.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nash_is_ppad_complete">NASH is PPAD-Complete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So NASH is no harder than PPAD, but is it any easier?</p>
</div>
<div class="paragraph">
<p>To show this, the authors first reduce solving an instance of END-OF-THE-LINE to solving an instance of BROUWER. After reading this part of the paper, I understand the gist of this reduction, but the details are described by the authors as "hard", and are left out. The idea is to that we&#8217;ll be looking for a fixed point in 3-space. The space is partitioned into tiny "cubelets". The centers of the cublets define a lattice, and the lattice nodes are to be colored with one of <em>four</em> colors (0, 1, 2, 3). Initially all nodes are colored "0". The mesh is fine enough so that each of the nodes in the END-OF-THE-LINE graph can be assigned to one cublet on each of the top-left and bottom right corners of the cube. If there is an edge from u to v in the END-OF-THE-LINE graph, then the coloring of the cublets on the interior of the cube can be defined so that the directions of F(x)-x will yield a edge rule much like with the triangular tessellation from earlier, and there is a path formed by these colorings from the top-left point corresponding to u to the bottom-left point corresponding to v. Likewise, the colors can be used to define a path from the bottom-left u to the top-left v. After this encoding is complete, define a function F such that F(x) - x produces a vector whose&#8217;s angle can be colored with one of the four colours used for the cublets. The authors claim (without proof here) that such a function can be defined so that it is easy to compute, and that it can be easily interpolated between the centers of the cubelets. If we had an efficient algorithm for BROUWER, we could then run that algorithm on F to find a fixed point, and such a fixed point would be a solution to END-OF-THE-LINE when its coordinates were mapped onto the nearest cublet. I can kind of see how this works, but don&#8217;t want to think too hard about it. The upshot is, BROUWER is PPAD-Complete, since it&#8217;s no harder than END-OF-THE-LINE, and END-OF-THE-LINE is no harder than BROUWER is.</p>
</div>
<div class="paragraph">
<p>The final step then is to show that if we had an efficient algorithm for NASH, we could efficiently solve BROUWER.</p>
</div>
<div class="sect2">
<h3 id="_games_as_boolean_circuits">Games as Boolean Circuits</h3>
<div class="paragraph">
<p>The first time I read over the paper, I skimmed this part, which seemed almost like a footnote tacked onto the end. However, on closer reading I found this to be the most exciting part!</p>
</div>
<div class="paragraph">
<p>Here&#8217;s the basic idea:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Suppose we have an instance of BROUWER with some function F. Recall that F must be easy to compute, with a polynomial-depth boolean circuit.</p>
</li>
<li>
<p>Define a game such that each gate in the boolean circuit representation of F is converted to the actions of some subset of players of the game. (Wat?)</p>
</li>
<li>
<p>Define some more players of the game the respectively decide the inputs and outputs for the boolean circuit. Link their payoffs, so that these players are only paid if they adopt identical strategies.</p>
</li>
<li>
<p>Show that, in the Nash equilibrium of this game, the input and output players must have identical values, and the computation players must faithfully implement $F$. This is only possible if the input is a fixed-point of F.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So the neat part of this proof was the process of defining a game that does arithmetic. The outline is that F can be broken down into just a few kinds of boolean functions, notable addition, multiplication, and comparison. You can make a game that computes each of these, and then compose these games together into a larger game.</p>
</div>
<div class="paragraph">
<p>The paper gives a nice example with for computing Z=X*Y. We define 4 players w,x,y,z. Each player can play one of two actions, "STOP" and "GO". Their strategy is then defined as a probability (W,X,Y,Z) of playing GO. We do not pay x or y anything in this subgame, so they&#8217;ll use whatever values they like. Usually these values will be defined by some other game. w gets paid X \times Y if it plays STOP, and Z if it plays GO. z gets paid X\times Y for playing GO, and W for playing STOP.  The unique equilibrium for this game is for w to play GO with probability X\times Y, and z to play GO with probability X\times Y. Thus, if x and y's probabilities of playing GO were fixed, then the probability that z plays GO is always X\times Y. We can then define the interior connections of the boolean circuit by connecting, e.g. z as the x or y player in some other circuit game.</p>
</div>
<div class="paragraph">
<p>The input of $F$ is a three-dimension value in a finite cube. Simply map the range (0,1) onto each axis of the cube, and define three players, one for each dimension. Like the others, they play either STOP or GO. Define three more points as players at the output of the F circuit in the same way. The payoffs for the six input players are set so that they are only in equilibrium when the three input players and the three output players represent the same point with their probabilities.</p>
</div>
<div class="paragraph">
<p>The big catch with this is that if our circuit for F had a polynomial number of gates n, then we have n+6 players each with a binary action, and thus a game with 2^{n+6} payoffs that need to be encoded. It&#8217;s not obvious that a game with exponential size like this can be compactly encoded. If it can&#8217;t, then the reduction from BROUWER to NASH is not polynomial time, and so even if we had a fast algorithm for NASH, we would still do exponential work to solve BROUWER (since we&#8217;d do exponential work just to convert an instance of BROUWER into an instance of NASH).</p>
</div>
<div class="paragraph">
<p>To fix this, the authors show that the game can be reduced to one played between 3 players. Basically, each boolean circuit will have some input players, some middle player, and some output player. As long as each of these groups is controlled by a different player, the circuit will end up in the right equilibrium. The authors show that you can color the players such that only three colors are needed, and therefore the game can be played by three people, each selecting between a linear number of actions that (Somehow? This point is not well explained) encode the exponential number of actions their gates might produce. The upshot is, any instance of BROUWER can be reduced to NASH for a 3-player game, so NASH with 3 players must be PPAD-Complete. Of course, it&#8217;s easy to make this maping with more than 3 players (just add some dummy players that don&#8217;t interact with the main 3). This means that NASH must be PPAD-Complete when there are 3 or more players.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_tidbits">Other Tidbits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The authors mention Bibelus as an author who showed that any game played among more than 3 players could be reduced to a game among exactly 3. Their results show this in a different way (I think: Convert the n-player game to its END-OF-THE-LINE instance, then convert that END-OF-THE-LINE instance into NASH for 3 players; a fixed point in this 3-player game can be converted back into a fixed point in the original game. Weird!). I think I should read the paper by Bibelus in the future.</p>
</div>
<div class="paragraph">
<p>The authors also reference a paper by Chen and Deng, that shows a much more surprising result: the circuits created by converting BROUWER to NASH never contain Multiply gates, and so can actually be colored using just <em>2</em> colors. This implies that the problem of finding an equilibrium in any n-player game can be efficiently converted into the problem of finding an equilibrium in a 2-player game, which seems ludicrous on the surface, but makes sense the more I think about it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_so_what">So What?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NASH is PPAD-Complete. PPAD looks hard (in fact, it seems there isn&#8217;t even a good stochastic approximation algorithm right now?).</p>
</div>
<div class="paragraph">
<p>Practically, this means it&#8217;s hard to predict how rational agents might play a game. Real-world games are pretty complex beasts (say, the global economy), so if our algorithms for solving them scale exponentially, then we probably can&#8217;t do much of anything.</p>
</div>
<div class="paragraph">
<p>Much more important is a point the authors raise: if it&#8217;s not tractable to find fixed points, then why would we suppose that agents would (could?) play strategies that lie at a fixed point? That is, if in general Nash equilibria cannot be found without exponential computational efforts, then does finding a Nash Equilibrium actually tell us much of anything? Maybe the whole solution concept is kind of useless.</p>
</div>
<div class="paragraph">
<p>The paper is also 8 years old. I haven&#8217;t heard anything about efficient algorithms (approximate or otherwise) for NASH, but I do wonder what sort of work people have done since towards this. Probably a reverse citation search on the paper would make it pretty apparent.</p>
</div>
<div class="paragraph">
<p>I wonder too about the implications of quantum computers for PPAD. I know NP and BQP overlap, but are not subsets of one another. Where exactly does PPAD sit relative to BQP? It certainly <em>seems</em> like the sort of thing that would be easy with something like Grover&#8217;s algorithm, because we&#8217;d have a polynomial depth circuit to act as an oracle. However, we&#8217;re not looking something that matches a signature, but something that&#8217;s unchanged when it goes through the function. Have people worked on this topic? Maybe I should ask Chris Grenade what he thinks about this.</p>
</div>
<div class="sect3">
<h4 id="_why_did_i_pick_this_paper">Why did I pick this paper?</h4>
<div class="paragraph">
<p>This is an older paper I&#8217;ve been meaning to read for a couple of years. One of the authors is Christos Papadimitriou. Papadimitriou does a lot of exciting work. The two things that come to my mind are co-inventing <a href="https://en.wikipedia.org/wiki/Price_of_anarchy">Price of Anarchy</a>, a metric for the cost of having self-interested (and rational) individuals do as they please, rather than imposing a solution on all of them from some central authority. It&#8217;s very useful in mechanism design, because it allows us to quantify the improvement in social utility from using a given mechanism, vs. allowing the agents to settle into whatever the usual Nash Equilibrium is for the game of interest. Papadimitriou has also done some work in genetic algorithms, which purports to show that mutation is entirely pointless in evolutionary search. I haven&#8217;t read the paper on this yet. Perhaps it should be my next review.</p>
</div>
</div>
</div>
</div>
        </section>

        <footer class="post-footer">


            <figure class="author-image">
                <a class="img" href="https://jdoncs.github.io/author/jdoncs/" style="background-image: url(https://avatars.githubusercontent.com/u/22714604?v&#x3D;3)"><span class="hidden">jdoncs's Picture</span></a>
            </figure>

            <section class="author">
                <h4><a href="https://jdoncs.github.io/author/jdoncs/">jdoncs</a></h4>

                    <p>Read <a href="https://jdoncs.github.io/author/jdoncs/">more posts</a> by this author.</p>
                <div class="author-meta">
                    
                    
                </div>
            </section>


            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="https://twitter.com/intent/tweet?text=Complexity%20of%20Computing%20a%20Nash%20Equilibrium&amp;url=https://jdoncs.github.io/2016/10/09/Complexity-of-Computing-a-Nash-Equilibrium.html"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://jdoncs.github.io/2016/10/09/Complexity-of-Computing-a-Nash-Equilibrium.html"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=https://jdoncs.github.io/2016/10/09/Complexity-of-Computing-a-Nash-Equilibrium.html"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>

        </footer>


    </article>

</main>

<aside class="read-next">
</aside>



        <footer class="site-footer clearfix">
            <section class="copyright"><a href="https://jdoncs.github.io"></a> &copy; 2016</section>
            <section class="poweredby">Proudly published with <a href="http://hubpress.io">HubPress</a></section>
        </footer>

    </div>

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();
      </script>

    <script type="text/javascript" src="//jdoncs.github.io/themes/casper/assets/js/jquery.fitvids.js?v=1476023861886"></script>
    <script type="text/javascript" src="//jdoncs.github.io/themes/casper/assets/js/index.js?v=1476023861886"></script>

</body>
</html>
